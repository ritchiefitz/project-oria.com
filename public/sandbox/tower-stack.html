<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Stack - Oria Sandbox</title>
<link rel="icon" type="image/svg+xml" href="../favicon.svg">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
  color: #e4e4e7;
  min-height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

header {
  padding: 1rem 5%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  backdrop-filter: blur(10px);
  background: rgba(10, 14, 39, 0.7);
  border-bottom: 1px solid rgba(99, 102, 241, 0.2);
  z-index: 10;
}

.logo {
  font-size: 1.5rem;
  font-weight: 800;
  background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-decoration: none;
}

nav a {
  color: #a1a1aa;
  text-decoration: none;
  margin-left: 1.5rem;
  font-weight: 500;
  transition: color 0.3s;
}
nav a:hover { color: #6366f1; }

.game-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}

canvas {
  display: block;
  border-radius: 12px;
  border: 1px solid rgba(99, 102, 241, 0.3);
  box-shadow: 0 0 40px rgba(99, 102, 241, 0.15);
}

.hud {
  position: absolute;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 2rem;
  z-index: 5;
  pointer-events: none;
}

.hud-item {
  text-align: center;
}

.hud-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: #a1a1aa;
}

.hud-value {
  font-size: 1.8rem;
  font-weight: 800;
  background: linear-gradient(135deg, #6366f1, #a855f7);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(10, 14, 39, 0.85);
  z-index: 10;
  transition: opacity 0.3s;
}

.overlay.hidden { display: none; }

.overlay h1 {
  font-size: 3rem;
  font-weight: 900;
  background: linear-gradient(135deg, #6366f1, #a855f7);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 0.5rem;
}

.overlay h2 {
  font-size: 1.5rem;
  color: #a1a1aa;
  margin-bottom: 1.5rem;
  font-weight: 400;
}

.overlay .final-score {
  font-size: 4rem;
  font-weight: 900;
  color: #fff;
  margin-bottom: 0.5rem;
}

.overlay .score-label {
  font-size: 1rem;
  color: #a1a1aa;
  margin-bottom: 2rem;
}

.overlay .best-score {
  font-size: 1rem;
  color: #6366f1;
  margin-bottom: 2rem;
}

.start-btn {
  padding: 1rem 3rem;
  font-size: 1.1rem;
  font-weight: 700;
  border: none;
  border-radius: 50px;
  background: linear-gradient(135deg, #6366f1, #a855f7);
  color: white;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  letter-spacing: 0.02em;
}
.start-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
}

.controls-hint {
  margin-top: 1.5rem;
  color: #71717a;
  font-size: 0.85rem;
}

.perfect-text {
  position: absolute;
  font-size: 2rem;
  font-weight: 900;
  color: #fbbf24;
  text-shadow: 0 0 20px rgba(251, 191, 36, 0.6);
  pointer-events: none;
  animation: perfectPop 0.8s ease-out forwards;
  z-index: 20;
}

@keyframes perfectPop {
  0% { transform: scale(0.5) translateY(0); opacity: 1; }
  50% { transform: scale(1.2) translateY(-20px); opacity: 1; }
  100% { transform: scale(1) translateY(-60px); opacity: 0; }
}

.combo-text {
  position: absolute;
  font-size: 1.2rem;
  font-weight: 700;
  color: #a855f7;
  text-shadow: 0 0 15px rgba(168, 85, 247, 0.5);
  pointer-events: none;
  animation: comboPop 0.6s ease-out forwards;
  z-index: 20;
}

@keyframes comboPop {
  0% { transform: scale(0.5); opacity: 1; }
  100% { transform: scale(1.1) translateY(-40px); opacity: 0; }
}

@media (max-width: 600px) {
  canvas { border-radius: 0; border: none; }
  .hud { top: 70px; gap: 1rem; }
  .hud-value { font-size: 1.4rem; }
  .overlay h1 { font-size: 2rem; }
}
</style>
</head>
<body>
<header>
  <a href="index.html" class="logo">ORIA</a>
  <nav>
    <a href="../index.html">Home</a>
    <a href="index.html">Sandbox</a>
  </nav>
</header>

<div class="game-container">
  <canvas id="game"></canvas>
  <div class="hud">
    <div class="hud-item">
      <div class="hud-label">Score</div>
      <div class="hud-value" id="scoreDisplay">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">Best</div>
      <div class="hud-value" id="bestDisplay">0</div>
    </div>
  </div>

  <div class="overlay" id="startOverlay">
    <h1>TOWER STACK</h1>
    <h2>Stack blocks as high as you can</h2>
    <button class="start-btn" id="startBtn">START GAME</button>
    <div class="controls-hint">Press SPACE or tap to drop blocks</div>
  </div>

  <div class="overlay hidden" id="gameOverOverlay">
    <h2>GAME OVER</h2>
    <div class="final-score" id="finalScore">0</div>
    <div class="score-label">BLOCKS STACKED</div>
    <div class="best-score" id="bestScoreText">Best: 0</div>
    <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
    <div class="controls-hint">Press SPACE or tap to restart</div>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Responsive canvas sizing
function resizeCanvas() {
  const maxW = 400, maxH = 600;
  const cw = Math.min(window.innerWidth - 20, maxW);
  const ch = Math.min(window.innerHeight - 80, maxH);
  canvas.width = cw;
  canvas.height = ch;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game state
let blocks = [];
let currentBlock = null;
let score = 0;
let bestScore = parseInt(localStorage.getItem('towerStackBest') || '0');
let gameRunning = false;
let combo = 0;
let cameraY = 0;
let targetCameraY = 0;
let particles = [];
let floatingTexts = [];
let speed = 2;
let direction = 1;

const BLOCK_HEIGHT = 28;
const PERFECT_THRESHOLD = 3;
const BASE_SPEED = 2.2;
const SPEED_INCREMENT = 0.12;
const MAX_SPEED = 7;

// Colors: generate a gradient of colors for each level
function getBlockColor(level) {
  const hues = [250, 270, 290, 310, 330, 350, 210, 230];
  const hue = hues[level % hues.length];
  return {
    top: `hsl(${hue}, 70%, 60%)`,
    front: `hsl(${hue}, 70%, 45%)`,
    right: `hsl(${hue}, 70%, 35%)`
  };
}

// UI elements
const scoreDisplay = document.getElementById('scoreDisplay');
const bestDisplay = document.getElementById('bestDisplay');
const startOverlay = document.getElementById('startOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const finalScoreEl = document.getElementById('finalScore');
const bestScoreText = document.getElementById('bestScoreText');

bestDisplay.textContent = bestScore;

class Block {
  constructor(x, y, width, level) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = BLOCK_HEIGHT;
    this.level = level;
    this.color = getBlockColor(level);
    this.settled = false;
    this.fallSpeed = 0;
    this.falling = false;
    this.alpha = 1;
  }

  draw(offsetY) {
    const drawY = this.y - offsetY;
    if (drawY > canvas.height + 50 || drawY < -100) return;

    ctx.globalAlpha = this.alpha;

    // Top face (lighter)
    ctx.fillStyle = this.color.top;
    ctx.fillRect(this.x, drawY, this.width, this.height);

    // Highlight on top edge
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(this.x, drawY, this.width, 3);

    // Shadow on bottom edge
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(this.x, drawY + this.height - 2, this.width, 2);

    // Left/right glow
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(this.x, drawY, 2, this.height);

    ctx.globalAlpha = 1;
  }

  update() {
    if (this.falling) {
      this.fallSpeed += 0.5;
      this.y += this.fallSpeed;
      this.alpha -= 0.02;
      if (this.alpha <= 0) return false;
    }
    return true;
  }
}

class Particle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 6;
    this.vy = -Math.random() * 4 - 1;
    this.life = 1;
    this.decay = Math.random() * 0.03 + 0.02;
    this.size = Math.random() * 4 + 2;
    this.color = color;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.15;
    this.life -= this.decay;
    return this.life > 0;
  }

  draw(offsetY) {
    const drawY = this.y - offsetY;
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x - this.size / 2, drawY - this.size / 2, this.size, this.size);
    ctx.globalAlpha = 1;
  }
}

function spawnParticles(x, y, width, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push(new Particle(x + Math.random() * width, y, color));
  }
}

function showFloatingText(text, x, y, type) {
  const el = document.createElement('div');
  el.className = type === 'perfect' ? 'perfect-text' : 'combo-text';
  el.textContent = text;
  el.style.left = `${canvas.getBoundingClientRect().left + x}px`;
  el.style.top = `${canvas.getBoundingClientRect().top + y}px`;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

function initGame() {
  blocks = [];
  particles = [];
  score = 0;
  combo = 0;
  cameraY = 0;
  targetCameraY = 0;
  speed = BASE_SPEED;
  direction = 1;

  scoreDisplay.textContent = '0';

  // Base block
  const baseWidth = canvas.width * 0.4;
  const baseX = (canvas.width - baseWidth) / 2;
  const baseY = canvas.height - BLOCK_HEIGHT - 40;
  const base = new Block(baseX, baseY, baseWidth, 0);
  base.settled = true;
  blocks.push(base);

  // Spawn first moving block
  spawnNextBlock();
  gameRunning = true;
}

function spawnNextBlock() {
  const topBlock = getTopSettledBlock();
  const newY = topBlock.y - BLOCK_HEIGHT;
  const startX = -topBlock.width;
  currentBlock = new Block(startX, newY, topBlock.width, blocks.filter(b => b.settled).length);
  direction = (blocks.filter(b => b.settled).length % 2 === 0) ? 1 : -1;
  currentBlock.x = direction === 1 ? -currentBlock.width : canvas.width;
}

function getTopSettledBlock() {
  let top = blocks[0];
  for (const b of blocks) {
    if (b.settled && b.y < top.y) top = b;
  }
  return top;
}

function dropBlock() {
  if (!currentBlock || !gameRunning) return;

  const topBlock = getTopSettledBlock();

  // Calculate overlap
  const currLeft = currentBlock.x;
  const currRight = currentBlock.x + currentBlock.width;
  const topLeft = topBlock.x;
  const topRight = topBlock.x + topBlock.width;

  const overlapLeft = Math.max(currLeft, topLeft);
  const overlapRight = Math.min(currRight, topRight);
  const overlapWidth = overlapRight - overlapLeft;

  if (overlapWidth <= 0) {
    // Missed completely
    currentBlock.falling = true;
    blocks.push(currentBlock);
    currentBlock = null;
    gameOver();
    return;
  }

  const offset = Math.abs(currentBlock.x - topBlock.x);

  if (offset <= PERFECT_THRESHOLD) {
    // Perfect placement - keep same width, align exactly
    currentBlock.x = topBlock.x;
    currentBlock.width = topBlock.width;
    currentBlock.settled = true;
    blocks.push(currentBlock);
    combo++;
    score += 1 + combo;

    const drawY = currentBlock.y - cameraY;
    spawnParticles(currentBlock.x, currentBlock.y, currentBlock.width, '#fbbf24', 20);
    showFloatingText('PERFECT!', canvas.width / 2 - 50, drawY - 20, 'perfect');

    if (combo > 1) {
      showFloatingText(`${combo}x COMBO`, canvas.width / 2 - 40, drawY + 10, 'combo');
    }
  } else {
    // Partial overlap - cut the excess
    combo = 0;

    // Create falling piece for the chopped part
    if (currLeft < topLeft) {
      // Overhang on left
      const chopWidth = topLeft - currLeft;
      const chop = new Block(currLeft, currentBlock.y, chopWidth, currentBlock.level);
      chop.falling = true;
      blocks.push(chop);
    }
    if (currRight > topRight) {
      // Overhang on right
      const chopWidth = currRight - topRight;
      const chop = new Block(topRight, currentBlock.y, chopWidth, currentBlock.level);
      chop.falling = true;
      blocks.push(chop);
    }

    currentBlock.x = overlapLeft;
    currentBlock.width = overlapWidth;
    currentBlock.settled = true;
    blocks.push(currentBlock);

    score += 1;
    spawnParticles(currentBlock.x, currentBlock.y, currentBlock.width, currentBlock.color.top, 8);
  }

  scoreDisplay.textContent = score;

  // Increase speed
  speed = Math.min(MAX_SPEED, BASE_SPEED + blocks.filter(b => b.settled).length * SPEED_INCREMENT);

  // Move camera up
  const settledCount = blocks.filter(b => b.settled).length;
  if (settledCount > 8) {
    targetCameraY = (settledCount - 8) * BLOCK_HEIGHT * -1;
    targetCameraY = currentBlock.y - (canvas.height - 300);
  }

  currentBlock = null;
  spawnNextBlock();
}

function gameOver() {
  gameRunning = false;
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('towerStackBest', bestScore.toString());
    bestDisplay.textContent = bestScore;
  }
  finalScoreEl.textContent = score;
  bestScoreText.textContent = `Best: ${bestScore}`;
  setTimeout(() => {
    gameOverOverlay.classList.remove('hidden');
  }, 500);
}

function drawBackground(offsetY) {
  // Faint grid lines
  ctx.strokeStyle = 'rgba(99, 102, 241, 0.06)';
  ctx.lineWidth = 1;
  const gridSize = 40;
  const startY = (offsetY % gridSize);

  for (let y = -startY; y < canvas.height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
  for (let x = 0; x < canvas.width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Height markers
  const settledCount = blocks.filter(b => b.settled).length - 1;
  if (settledCount > 0) {
    ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
    ctx.font = '11px Inter, system-ui, sans-serif';
    ctx.textAlign = 'right';
    for (let i = 5; i <= settledCount; i += 5) {
      const markerY = blocks[0].y - (i * BLOCK_HEIGHT) - offsetY + BLOCK_HEIGHT / 2;
      if (markerY > 20 && markerY < canvas.height - 10) {
        ctx.fillText(`${i}`, canvas.width - 8, markerY + 4);
      }
    }
    ctx.textAlign = 'left';
  }
}

function update() {
  // Smooth camera
  cameraY += (targetCameraY - cameraY) * 0.08;

  // Move current block
  if (currentBlock && gameRunning) {
    currentBlock.x += speed * direction;

    // Bounce off edges with some margin
    if (currentBlock.x + currentBlock.width > canvas.width + 20) {
      direction = -1;
    } else if (currentBlock.x < -20) {
      direction = 1;
    }
  }

  // Update falling blocks
  blocks = blocks.filter(b => b.update());

  // Update particles
  particles = particles.filter(p => p.update());
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, '#0a0e27');
  grad.addColorStop(0.5, '#1a1a2e');
  grad.addColorStop(1, '#16213e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawBackground(cameraY);

  // Draw settled blocks
  for (const block of blocks) {
    block.draw(cameraY);
  }

  // Draw current moving block
  if (currentBlock) {
    currentBlock.draw(cameraY);

    // Draw guide lines
    if (gameRunning) {
      const topBlock = getTopSettledBlock();
      const drawTopY = topBlock.y - cameraY;
      ctx.strokeStyle = 'rgba(99, 102, 241, 0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      // Left edge guide
      ctx.beginPath();
      ctx.moveTo(topBlock.x, drawTopY);
      ctx.lineTo(topBlock.x, drawTopY - 80);
      ctx.stroke();
      // Right edge guide
      ctx.beginPath();
      ctx.moveTo(topBlock.x + topBlock.width, drawTopY);
      ctx.lineTo(topBlock.x + topBlock.width, drawTopY - 80);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  // Draw particles
  for (const p of particles) {
    p.draw(cameraY);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Event listeners
function handleInput(e) {
  if (e) e.preventDefault();

  if (!gameRunning) {
    if (!startOverlay.classList.contains('hidden')) {
      startOverlay.classList.add('hidden');
      initGame();
    } else if (!gameOverOverlay.classList.contains('hidden')) {
      gameOverOverlay.classList.add('hidden');
      initGame();
    }
    return;
  }
  dropBlock();
}

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'Enter') {
    handleInput(e);
  }
});

canvas.addEventListener('click', handleInput);
canvas.addEventListener('touchstart', handleInput, { passive: false });

document.getElementById('startBtn').addEventListener('click', (e) => {
  e.stopPropagation();
  startOverlay.classList.add('hidden');
  initGame();
});

document.getElementById('restartBtn').addEventListener('click', (e) => {
  e.stopPropagation();
  gameOverOverlay.classList.add('hidden');
  initGame();
});

// Start render loop
gameLoop();
</script>
</body>
</html>
